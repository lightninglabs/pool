// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package poolrpc

import (
	context "context"
	auctioneerrpc "github.com/lightninglabs/pool/auctioneerrpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TraderClient is the client API for Trader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TraderClient interface {
	// pool: `getinfo`
	// GetInfo returns general information about the state of the Pool trader
	// daemon.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// pool: `stop`
	// Stop gracefully shuts down the Pool trader daemon.
	StopDaemon(ctx context.Context, in *StopDaemonRequest, opts ...grpc.CallOption) (*StopDaemonResponse, error)
	// QuoteAccount gets a fee quote to fund an account of the given size with the
	// given confirmation target. If the connected lnd wallet doesn't have enough
	// balance to fund an account of the requested size, an error is returned.
	QuoteAccount(ctx context.Context, in *QuoteAccountRequest, opts ...grpc.CallOption) (*QuoteAccountResponse, error)
	// pool: `accounts new`
	// InitAccount creates a new account with the requested size and expiration,
	// funding it from the wallet of the connected lnd node.
	InitAccount(ctx context.Context, in *InitAccountRequest, opts ...grpc.CallOption) (*Account, error)
	// pool: `accounts list`
	// ListAccounts returns a list of all accounts known to the trader daemon and
	// their current state.
	ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error)
	// pool: `accounts close`
	// CloseAccount closes an account and returns the funds locked in that account
	// to the connected lnd node's wallet.
	CloseAccount(ctx context.Context, in *CloseAccountRequest, opts ...grpc.CallOption) (*CloseAccountResponse, error)
	// pool: `accounts withdraw`
	// WithdrawAccount splits off parts of the account balance into the specified
	// outputs while recreating the account with a reduced balance.
	WithdrawAccount(ctx context.Context, in *WithdrawAccountRequest, opts ...grpc.CallOption) (*WithdrawAccountResponse, error)
	// pool: `accounts deposit`
	// DepositAccount adds more funds from the connected lnd node's wallet to an
	// account.
	DepositAccount(ctx context.Context, in *DepositAccountRequest, opts ...grpc.CallOption) (*DepositAccountResponse, error)
	// pool: `accounts renew`
	// RenewAccount renews the expiration of an account.
	RenewAccount(ctx context.Context, in *RenewAccountRequest, opts ...grpc.CallOption) (*RenewAccountResponse, error)
	// pool: `accounts bumpfee`
	// BumpAccountFee attempts to bump the fee of an account's transaction through
	// child-pays-for-parent (CPFP). Since the CPFP is performed through the
	// backing lnd node, the account transaction must contain an output under its
	// control for a successful bump. If a CPFP has already been performed for an
	// account, and this RPC is invoked again, then a replacing transaction (RBF)
	// of the child will be broadcast.
	BumpAccountFee(ctx context.Context, in *BumpAccountFeeRequest, opts ...grpc.CallOption) (*BumpAccountFeeResponse, error)
	// pool: `accounts recover`
	// RecoverAccounts queries the auction server for this trader daemon's accounts
	// in case we lost our local account database.
	RecoverAccounts(ctx context.Context, in *RecoverAccountsRequest, opts ...grpc.CallOption) (*RecoverAccountsResponse, error)
	// pool: `accounts listfees`
	// AccountModificationFees returns a map from account key to an ordered list of
	// account action modification fees.
	AccountModificationFees(ctx context.Context, in *AccountModificationFeesRequest, opts ...grpc.CallOption) (*AccountModificationFeesResponse, error)
	// pool: `orders submit`
	// SubmitOrder creates a new ask or bid order and submits for the given account
	// and submits it to the auction server for matching.
	SubmitOrder(ctx context.Context, in *SubmitOrderRequest, opts ...grpc.CallOption) (*SubmitOrderResponse, error)
	// pool: `orders list`
	// ListOrders returns a list of all active and archived orders that are
	// currently known to the trader daemon.
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// pool: `orders cancel`
	// CancelOrder cancels an active order with the auction server to remove it
	// from future matching.
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error)
	// QuoteOrder calculates the premium, execution fees and max batch fee rate for
	// an order based on the given order parameters.
	QuoteOrder(ctx context.Context, in *QuoteOrderRequest, opts ...grpc.CallOption) (*QuoteOrderResponse, error)
	// pool: `auction fee`
	// AuctionFee returns the current auction order execution fee specified by the
	// auction server.
	AuctionFee(ctx context.Context, in *AuctionFeeRequest, opts ...grpc.CallOption) (*AuctionFeeResponse, error)
	// pool: `auction leasedurations`
	// LeaseDurations returns the current set of valid lease duration in the
	// market as is, and also information w.r.t if the market is currently active.
	LeaseDurations(ctx context.Context, in *LeaseDurationRequest, opts ...grpc.CallOption) (*LeaseDurationResponse, error)
	// pool: `auction nextbatchinfo`
	// NextBatchInfo returns information about the next batch the auctioneer will
	// perform.
	NextBatchInfo(ctx context.Context, in *NextBatchInfoRequest, opts ...grpc.CallOption) (*NextBatchInfoResponse, error)
	// pool: `auction snapshot`
	// BatchSnapshot returns the snapshot of a past batch identified by its ID.
	// If no ID is provided, the snapshot of the last finalized batch is returned.
	// Deprecated, use BatchSnapshots instead.
	BatchSnapshot(ctx context.Context, in *auctioneerrpc.BatchSnapshotRequest, opts ...grpc.CallOption) (*auctioneerrpc.BatchSnapshotResponse, error)
	// pool: `listauth`
	// GetLsatTokens returns all LSAT tokens the daemon ever paid for.
	GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error)
	// pool: `auction leases`
	// Leases returns the list of channels that were either purchased or sold by
	// the trader within the auction.
	Leases(ctx context.Context, in *LeasesRequest, opts ...grpc.CallOption) (*LeasesResponse, error)
	// pool: `auction ratings`
	// Returns the Node Tier information for this target Lightning node, and other
	// related ranking information.
	NodeRatings(ctx context.Context, in *NodeRatingRequest, opts ...grpc.CallOption) (*NodeRatingResponse, error)
	// pool: `auction snapshot`
	// BatchSnapshots returns a list of batch snapshots starting at the start batch
	// ID and going back through the history of batches, returning at most the
	// number of specified batches. A maximum of 100 snapshots can be queried in
	// one call. If no start batch ID is provided, the most recent finalized batch
	// is used as the starting point to go back from.
	BatchSnapshots(ctx context.Context, in *auctioneerrpc.BatchSnapshotsRequest, opts ...grpc.CallOption) (*auctioneerrpc.BatchSnapshotsResponse, error)
	// pool: `sidecar offer`
	// OfferSidecar is step 1/4 of the sidecar negotiation between the provider
	// (the trader submitting the bid order) and the recipient (the trader
	// receiving the sidecar channel).
	// This step must be run by the provider. The result is a sidecar ticket with
	// an offer to lease a sidecar channel for the recipient. The offer will be
	// signed with the provider's lnd node public key. The ticket returned by this
	// call will have the state "offered".
	OfferSidecar(ctx context.Context, in *OfferSidecarRequest, opts ...grpc.CallOption) (*SidecarTicket, error)
	// pool: `sidecar register`
	// RegisterSidecarRequest is step 2/4 of the sidecar negotiation between the
	// provider (the trader submitting the bid order) and the recipient (the trader
	// receiving the sidecar channel).
	// This step must be run by the recipient. The result is a sidecar ticket with
	// the recipient's node information and channel funding multisig pubkey filled
	// in. The ticket returned by this call will have the state "registered".
	RegisterSidecar(ctx context.Context, in *RegisterSidecarRequest, opts ...grpc.CallOption) (*SidecarTicket, error)
	// pool: `sidecar expectchannel`
	// ExpectSidecarChannel is step 4/4 of the sidecar negotiation between the
	// provider (the trader submitting the bid order) and the recipient (the trader
	// receiving the sidecar channel).
	// This step must be run by the recipient once the provider has submitted the
	// bid order for the sidecar channel. From this point onwards the Pool trader
	// daemon of both the provider as well as the recipient need to be online to
	// receive and react to match making events from the server.
	ExpectSidecarChannel(ctx context.Context, in *ExpectSidecarChannelRequest, opts ...grpc.CallOption) (*ExpectSidecarChannelResponse, error)
	// pool: `sidecar printticket`
	// Decodes the base58 encoded sidecar ticket into its individual data fields
	// for a more human-readable representation.
	DecodeSidecarTicket(ctx context.Context, in *SidecarTicket, opts ...grpc.CallOption) (*DecodedSidecarTicket, error)
	// pool: `sidecar list`
	// ListSidecars lists all sidecar tickets currently in the local database. This
	// includes tickets offered by our node as well as tickets that our node is the
	// recipient of. Optionally a ticket ID can be provided to filter the tickets.
	ListSidecars(ctx context.Context, in *ListSidecarsRequest, opts ...grpc.CallOption) (*ListSidecarsResponse, error)
	// pool: `sidecar cancel`
	// CancelSidecar cancels the execution of a specific sidecar ticket. Depending
	// on the state of the sidecar ticket its associated bid order might be
	// canceled as well (if this ticket was offered by our node).
	CancelSidecar(ctx context.Context, in *CancelSidecarRequest, opts ...grpc.CallOption) (*CancelSidecarResponse, error)
}

type traderClient struct {
	cc grpc.ClientConnInterface
}

func NewTraderClient(cc grpc.ClientConnInterface) TraderClient {
	return &traderClient{cc}
}

func (c *traderClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/GetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) StopDaemon(ctx context.Context, in *StopDaemonRequest, opts ...grpc.CallOption) (*StopDaemonResponse, error) {
	out := new(StopDaemonResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/StopDaemon", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) QuoteAccount(ctx context.Context, in *QuoteAccountRequest, opts ...grpc.CallOption) (*QuoteAccountResponse, error) {
	out := new(QuoteAccountResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/QuoteAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) InitAccount(ctx context.Context, in *InitAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/InitAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error) {
	out := new(ListAccountsResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/ListAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) CloseAccount(ctx context.Context, in *CloseAccountRequest, opts ...grpc.CallOption) (*CloseAccountResponse, error) {
	out := new(CloseAccountResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/CloseAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) WithdrawAccount(ctx context.Context, in *WithdrawAccountRequest, opts ...grpc.CallOption) (*WithdrawAccountResponse, error) {
	out := new(WithdrawAccountResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/WithdrawAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) DepositAccount(ctx context.Context, in *DepositAccountRequest, opts ...grpc.CallOption) (*DepositAccountResponse, error) {
	out := new(DepositAccountResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/DepositAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) RenewAccount(ctx context.Context, in *RenewAccountRequest, opts ...grpc.CallOption) (*RenewAccountResponse, error) {
	out := new(RenewAccountResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/RenewAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) BumpAccountFee(ctx context.Context, in *BumpAccountFeeRequest, opts ...grpc.CallOption) (*BumpAccountFeeResponse, error) {
	out := new(BumpAccountFeeResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/BumpAccountFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) RecoverAccounts(ctx context.Context, in *RecoverAccountsRequest, opts ...grpc.CallOption) (*RecoverAccountsResponse, error) {
	out := new(RecoverAccountsResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/RecoverAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) AccountModificationFees(ctx context.Context, in *AccountModificationFeesRequest, opts ...grpc.CallOption) (*AccountModificationFeesResponse, error) {
	out := new(AccountModificationFeesResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/AccountModificationFees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) SubmitOrder(ctx context.Context, in *SubmitOrderRequest, opts ...grpc.CallOption) (*SubmitOrderResponse, error) {
	out := new(SubmitOrderResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/SubmitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error) {
	out := new(CancelOrderResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) QuoteOrder(ctx context.Context, in *QuoteOrderRequest, opts ...grpc.CallOption) (*QuoteOrderResponse, error) {
	out := new(QuoteOrderResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/QuoteOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) AuctionFee(ctx context.Context, in *AuctionFeeRequest, opts ...grpc.CallOption) (*AuctionFeeResponse, error) {
	out := new(AuctionFeeResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/AuctionFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) LeaseDurations(ctx context.Context, in *LeaseDurationRequest, opts ...grpc.CallOption) (*LeaseDurationResponse, error) {
	out := new(LeaseDurationResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/LeaseDurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) NextBatchInfo(ctx context.Context, in *NextBatchInfoRequest, opts ...grpc.CallOption) (*NextBatchInfoResponse, error) {
	out := new(NextBatchInfoResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/NextBatchInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) BatchSnapshot(ctx context.Context, in *auctioneerrpc.BatchSnapshotRequest, opts ...grpc.CallOption) (*auctioneerrpc.BatchSnapshotResponse, error) {
	out := new(auctioneerrpc.BatchSnapshotResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/BatchSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error) {
	out := new(TokensResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/GetLsatTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) Leases(ctx context.Context, in *LeasesRequest, opts ...grpc.CallOption) (*LeasesResponse, error) {
	out := new(LeasesResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/Leases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) NodeRatings(ctx context.Context, in *NodeRatingRequest, opts ...grpc.CallOption) (*NodeRatingResponse, error) {
	out := new(NodeRatingResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/NodeRatings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) BatchSnapshots(ctx context.Context, in *auctioneerrpc.BatchSnapshotsRequest, opts ...grpc.CallOption) (*auctioneerrpc.BatchSnapshotsResponse, error) {
	out := new(auctioneerrpc.BatchSnapshotsResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/BatchSnapshots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) OfferSidecar(ctx context.Context, in *OfferSidecarRequest, opts ...grpc.CallOption) (*SidecarTicket, error) {
	out := new(SidecarTicket)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/OfferSidecar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) RegisterSidecar(ctx context.Context, in *RegisterSidecarRequest, opts ...grpc.CallOption) (*SidecarTicket, error) {
	out := new(SidecarTicket)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/RegisterSidecar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) ExpectSidecarChannel(ctx context.Context, in *ExpectSidecarChannelRequest, opts ...grpc.CallOption) (*ExpectSidecarChannelResponse, error) {
	out := new(ExpectSidecarChannelResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/ExpectSidecarChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) DecodeSidecarTicket(ctx context.Context, in *SidecarTicket, opts ...grpc.CallOption) (*DecodedSidecarTicket, error) {
	out := new(DecodedSidecarTicket)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/DecodeSidecarTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) ListSidecars(ctx context.Context, in *ListSidecarsRequest, opts ...grpc.CallOption) (*ListSidecarsResponse, error) {
	out := new(ListSidecarsResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/ListSidecars", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traderClient) CancelSidecar(ctx context.Context, in *CancelSidecarRequest, opts ...grpc.CallOption) (*CancelSidecarResponse, error) {
	out := new(CancelSidecarResponse)
	err := c.cc.Invoke(ctx, "/poolrpc.Trader/CancelSidecar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TraderServer is the server API for Trader service.
// All implementations must embed UnimplementedTraderServer
// for forward compatibility
type TraderServer interface {
	// pool: `getinfo`
	// GetInfo returns general information about the state of the Pool trader
	// daemon.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// pool: `stop`
	// Stop gracefully shuts down the Pool trader daemon.
	StopDaemon(context.Context, *StopDaemonRequest) (*StopDaemonResponse, error)
	// QuoteAccount gets a fee quote to fund an account of the given size with the
	// given confirmation target. If the connected lnd wallet doesn't have enough
	// balance to fund an account of the requested size, an error is returned.
	QuoteAccount(context.Context, *QuoteAccountRequest) (*QuoteAccountResponse, error)
	// pool: `accounts new`
	// InitAccount creates a new account with the requested size and expiration,
	// funding it from the wallet of the connected lnd node.
	InitAccount(context.Context, *InitAccountRequest) (*Account, error)
	// pool: `accounts list`
	// ListAccounts returns a list of all accounts known to the trader daemon and
	// their current state.
	ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error)
	// pool: `accounts close`
	// CloseAccount closes an account and returns the funds locked in that account
	// to the connected lnd node's wallet.
	CloseAccount(context.Context, *CloseAccountRequest) (*CloseAccountResponse, error)
	// pool: `accounts withdraw`
	// WithdrawAccount splits off parts of the account balance into the specified
	// outputs while recreating the account with a reduced balance.
	WithdrawAccount(context.Context, *WithdrawAccountRequest) (*WithdrawAccountResponse, error)
	// pool: `accounts deposit`
	// DepositAccount adds more funds from the connected lnd node's wallet to an
	// account.
	DepositAccount(context.Context, *DepositAccountRequest) (*DepositAccountResponse, error)
	// pool: `accounts renew`
	// RenewAccount renews the expiration of an account.
	RenewAccount(context.Context, *RenewAccountRequest) (*RenewAccountResponse, error)
	// pool: `accounts bumpfee`
	// BumpAccountFee attempts to bump the fee of an account's transaction through
	// child-pays-for-parent (CPFP). Since the CPFP is performed through the
	// backing lnd node, the account transaction must contain an output under its
	// control for a successful bump. If a CPFP has already been performed for an
	// account, and this RPC is invoked again, then a replacing transaction (RBF)
	// of the child will be broadcast.
	BumpAccountFee(context.Context, *BumpAccountFeeRequest) (*BumpAccountFeeResponse, error)
	// pool: `accounts recover`
	// RecoverAccounts queries the auction server for this trader daemon's accounts
	// in case we lost our local account database.
	RecoverAccounts(context.Context, *RecoverAccountsRequest) (*RecoverAccountsResponse, error)
	// pool: `accounts listfees`
	// AccountModificationFees returns a map from account key to an ordered list of
	// account action modification fees.
	AccountModificationFees(context.Context, *AccountModificationFeesRequest) (*AccountModificationFeesResponse, error)
	// pool: `orders submit`
	// SubmitOrder creates a new ask or bid order and submits for the given account
	// and submits it to the auction server for matching.
	SubmitOrder(context.Context, *SubmitOrderRequest) (*SubmitOrderResponse, error)
	// pool: `orders list`
	// ListOrders returns a list of all active and archived orders that are
	// currently known to the trader daemon.
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// pool: `orders cancel`
	// CancelOrder cancels an active order with the auction server to remove it
	// from future matching.
	CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error)
	// QuoteOrder calculates the premium, execution fees and max batch fee rate for
	// an order based on the given order parameters.
	QuoteOrder(context.Context, *QuoteOrderRequest) (*QuoteOrderResponse, error)
	// pool: `auction fee`
	// AuctionFee returns the current auction order execution fee specified by the
	// auction server.
	AuctionFee(context.Context, *AuctionFeeRequest) (*AuctionFeeResponse, error)
	// pool: `auction leasedurations`
	// LeaseDurations returns the current set of valid lease duration in the
	// market as is, and also information w.r.t if the market is currently active.
	LeaseDurations(context.Context, *LeaseDurationRequest) (*LeaseDurationResponse, error)
	// pool: `auction nextbatchinfo`
	// NextBatchInfo returns information about the next batch the auctioneer will
	// perform.
	NextBatchInfo(context.Context, *NextBatchInfoRequest) (*NextBatchInfoResponse, error)
	// pool: `auction snapshot`
	// BatchSnapshot returns the snapshot of a past batch identified by its ID.
	// If no ID is provided, the snapshot of the last finalized batch is returned.
	// Deprecated, use BatchSnapshots instead.
	BatchSnapshot(context.Context, *auctioneerrpc.BatchSnapshotRequest) (*auctioneerrpc.BatchSnapshotResponse, error)
	// pool: `listauth`
	// GetLsatTokens returns all LSAT tokens the daemon ever paid for.
	GetLsatTokens(context.Context, *TokensRequest) (*TokensResponse, error)
	// pool: `auction leases`
	// Leases returns the list of channels that were either purchased or sold by
	// the trader within the auction.
	Leases(context.Context, *LeasesRequest) (*LeasesResponse, error)
	// pool: `auction ratings`
	// Returns the Node Tier information for this target Lightning node, and other
	// related ranking information.
	NodeRatings(context.Context, *NodeRatingRequest) (*NodeRatingResponse, error)
	// pool: `auction snapshot`
	// BatchSnapshots returns a list of batch snapshots starting at the start batch
	// ID and going back through the history of batches, returning at most the
	// number of specified batches. A maximum of 100 snapshots can be queried in
	// one call. If no start batch ID is provided, the most recent finalized batch
	// is used as the starting point to go back from.
	BatchSnapshots(context.Context, *auctioneerrpc.BatchSnapshotsRequest) (*auctioneerrpc.BatchSnapshotsResponse, error)
	// pool: `sidecar offer`
	// OfferSidecar is step 1/4 of the sidecar negotiation between the provider
	// (the trader submitting the bid order) and the recipient (the trader
	// receiving the sidecar channel).
	// This step must be run by the provider. The result is a sidecar ticket with
	// an offer to lease a sidecar channel for the recipient. The offer will be
	// signed with the provider's lnd node public key. The ticket returned by this
	// call will have the state "offered".
	OfferSidecar(context.Context, *OfferSidecarRequest) (*SidecarTicket, error)
	// pool: `sidecar register`
	// RegisterSidecarRequest is step 2/4 of the sidecar negotiation between the
	// provider (the trader submitting the bid order) and the recipient (the trader
	// receiving the sidecar channel).
	// This step must be run by the recipient. The result is a sidecar ticket with
	// the recipient's node information and channel funding multisig pubkey filled
	// in. The ticket returned by this call will have the state "registered".
	RegisterSidecar(context.Context, *RegisterSidecarRequest) (*SidecarTicket, error)
	// pool: `sidecar expectchannel`
	// ExpectSidecarChannel is step 4/4 of the sidecar negotiation between the
	// provider (the trader submitting the bid order) and the recipient (the trader
	// receiving the sidecar channel).
	// This step must be run by the recipient once the provider has submitted the
	// bid order for the sidecar channel. From this point onwards the Pool trader
	// daemon of both the provider as well as the recipient need to be online to
	// receive and react to match making events from the server.
	ExpectSidecarChannel(context.Context, *ExpectSidecarChannelRequest) (*ExpectSidecarChannelResponse, error)
	// pool: `sidecar printticket`
	// Decodes the base58 encoded sidecar ticket into its individual data fields
	// for a more human-readable representation.
	DecodeSidecarTicket(context.Context, *SidecarTicket) (*DecodedSidecarTicket, error)
	// pool: `sidecar list`
	// ListSidecars lists all sidecar tickets currently in the local database. This
	// includes tickets offered by our node as well as tickets that our node is the
	// recipient of. Optionally a ticket ID can be provided to filter the tickets.
	ListSidecars(context.Context, *ListSidecarsRequest) (*ListSidecarsResponse, error)
	// pool: `sidecar cancel`
	// CancelSidecar cancels the execution of a specific sidecar ticket. Depending
	// on the state of the sidecar ticket its associated bid order might be
	// canceled as well (if this ticket was offered by our node).
	CancelSidecar(context.Context, *CancelSidecarRequest) (*CancelSidecarResponse, error)
	mustEmbedUnimplementedTraderServer()
}

// UnimplementedTraderServer must be embedded to have forward compatible implementations.
type UnimplementedTraderServer struct {
}

func (UnimplementedTraderServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedTraderServer) StopDaemon(context.Context, *StopDaemonRequest) (*StopDaemonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopDaemon not implemented")
}
func (UnimplementedTraderServer) QuoteAccount(context.Context, *QuoteAccountRequest) (*QuoteAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuoteAccount not implemented")
}
func (UnimplementedTraderServer) InitAccount(context.Context, *InitAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitAccount not implemented")
}
func (UnimplementedTraderServer) ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccounts not implemented")
}
func (UnimplementedTraderServer) CloseAccount(context.Context, *CloseAccountRequest) (*CloseAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseAccount not implemented")
}
func (UnimplementedTraderServer) WithdrawAccount(context.Context, *WithdrawAccountRequest) (*WithdrawAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawAccount not implemented")
}
func (UnimplementedTraderServer) DepositAccount(context.Context, *DepositAccountRequest) (*DepositAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositAccount not implemented")
}
func (UnimplementedTraderServer) RenewAccount(context.Context, *RenewAccountRequest) (*RenewAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenewAccount not implemented")
}
func (UnimplementedTraderServer) BumpAccountFee(context.Context, *BumpAccountFeeRequest) (*BumpAccountFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BumpAccountFee not implemented")
}
func (UnimplementedTraderServer) RecoverAccounts(context.Context, *RecoverAccountsRequest) (*RecoverAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverAccounts not implemented")
}
func (UnimplementedTraderServer) AccountModificationFees(context.Context, *AccountModificationFeesRequest) (*AccountModificationFeesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountModificationFees not implemented")
}
func (UnimplementedTraderServer) SubmitOrder(context.Context, *SubmitOrderRequest) (*SubmitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitOrder not implemented")
}
func (UnimplementedTraderServer) ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}
func (UnimplementedTraderServer) CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedTraderServer) QuoteOrder(context.Context, *QuoteOrderRequest) (*QuoteOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuoteOrder not implemented")
}
func (UnimplementedTraderServer) AuctionFee(context.Context, *AuctionFeeRequest) (*AuctionFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuctionFee not implemented")
}
func (UnimplementedTraderServer) LeaseDurations(context.Context, *LeaseDurationRequest) (*LeaseDurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaseDurations not implemented")
}
func (UnimplementedTraderServer) NextBatchInfo(context.Context, *NextBatchInfoRequest) (*NextBatchInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextBatchInfo not implemented")
}
func (UnimplementedTraderServer) BatchSnapshot(context.Context, *auctioneerrpc.BatchSnapshotRequest) (*auctioneerrpc.BatchSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSnapshot not implemented")
}
func (UnimplementedTraderServer) GetLsatTokens(context.Context, *TokensRequest) (*TokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLsatTokens not implemented")
}
func (UnimplementedTraderServer) Leases(context.Context, *LeasesRequest) (*LeasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Leases not implemented")
}
func (UnimplementedTraderServer) NodeRatings(context.Context, *NodeRatingRequest) (*NodeRatingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeRatings not implemented")
}
func (UnimplementedTraderServer) BatchSnapshots(context.Context, *auctioneerrpc.BatchSnapshotsRequest) (*auctioneerrpc.BatchSnapshotsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSnapshots not implemented")
}
func (UnimplementedTraderServer) OfferSidecar(context.Context, *OfferSidecarRequest) (*SidecarTicket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OfferSidecar not implemented")
}
func (UnimplementedTraderServer) RegisterSidecar(context.Context, *RegisterSidecarRequest) (*SidecarTicket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSidecar not implemented")
}
func (UnimplementedTraderServer) ExpectSidecarChannel(context.Context, *ExpectSidecarChannelRequest) (*ExpectSidecarChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExpectSidecarChannel not implemented")
}
func (UnimplementedTraderServer) DecodeSidecarTicket(context.Context, *SidecarTicket) (*DecodedSidecarTicket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeSidecarTicket not implemented")
}
func (UnimplementedTraderServer) ListSidecars(context.Context, *ListSidecarsRequest) (*ListSidecarsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSidecars not implemented")
}
func (UnimplementedTraderServer) CancelSidecar(context.Context, *CancelSidecarRequest) (*CancelSidecarResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSidecar not implemented")
}
func (UnimplementedTraderServer) mustEmbedUnimplementedTraderServer() {}

// UnsafeTraderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TraderServer will
// result in compilation errors.
type UnsafeTraderServer interface {
	mustEmbedUnimplementedTraderServer()
}

func RegisterTraderServer(s grpc.ServiceRegistrar, srv TraderServer) {
	s.RegisterService(&Trader_ServiceDesc, srv)
}

func _Trader_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDaemonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).StopDaemon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/StopDaemon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).StopDaemon(ctx, req.(*StopDaemonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_QuoteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).QuoteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/QuoteAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).QuoteAccount(ctx, req.(*QuoteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_InitAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).InitAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/InitAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).InitAccount(ctx, req.(*InitAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/ListAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).ListAccounts(ctx, req.(*ListAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_CloseAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).CloseAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/CloseAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).CloseAccount(ctx, req.(*CloseAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_WithdrawAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).WithdrawAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/WithdrawAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).WithdrawAccount(ctx, req.(*WithdrawAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_DepositAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).DepositAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/DepositAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).DepositAccount(ctx, req.(*DepositAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_RenewAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).RenewAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/RenewAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).RenewAccount(ctx, req.(*RenewAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_BumpAccountFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BumpAccountFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).BumpAccountFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/BumpAccountFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).BumpAccountFee(ctx, req.(*BumpAccountFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_RecoverAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoverAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).RecoverAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/RecoverAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).RecoverAccounts(ctx, req.(*RecoverAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_AccountModificationFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountModificationFeesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).AccountModificationFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/AccountModificationFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).AccountModificationFees(ctx, req.(*AccountModificationFeesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_SubmitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).SubmitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/SubmitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).SubmitOrder(ctx, req.(*SubmitOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_QuoteOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).QuoteOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/QuoteOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).QuoteOrder(ctx, req.(*QuoteOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_AuctionFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuctionFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).AuctionFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/AuctionFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).AuctionFee(ctx, req.(*AuctionFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_LeaseDurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseDurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).LeaseDurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/LeaseDurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).LeaseDurations(ctx, req.(*LeaseDurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_NextBatchInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextBatchInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).NextBatchInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/NextBatchInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).NextBatchInfo(ctx, req.(*NextBatchInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_BatchSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auctioneerrpc.BatchSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).BatchSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/BatchSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).BatchSnapshot(ctx, req.(*auctioneerrpc.BatchSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_GetLsatTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).GetLsatTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/GetLsatTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).GetLsatTokens(ctx, req.(*TokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_Leases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).Leases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/Leases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).Leases(ctx, req.(*LeasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_NodeRatings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRatingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).NodeRatings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/NodeRatings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).NodeRatings(ctx, req.(*NodeRatingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_BatchSnapshots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auctioneerrpc.BatchSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).BatchSnapshots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/BatchSnapshots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).BatchSnapshots(ctx, req.(*auctioneerrpc.BatchSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_OfferSidecar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OfferSidecarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).OfferSidecar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/OfferSidecar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).OfferSidecar(ctx, req.(*OfferSidecarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_RegisterSidecar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSidecarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).RegisterSidecar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/RegisterSidecar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).RegisterSidecar(ctx, req.(*RegisterSidecarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_ExpectSidecarChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpectSidecarChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).ExpectSidecarChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/ExpectSidecarChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).ExpectSidecarChannel(ctx, req.(*ExpectSidecarChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_DecodeSidecarTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SidecarTicket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).DecodeSidecarTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/DecodeSidecarTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).DecodeSidecarTicket(ctx, req.(*SidecarTicket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_ListSidecars_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSidecarsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).ListSidecars(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/ListSidecars",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).ListSidecars(ctx, req.(*ListSidecarsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trader_CancelSidecar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelSidecarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraderServer).CancelSidecar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/poolrpc.Trader/CancelSidecar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraderServer).CancelSidecar(ctx, req.(*CancelSidecarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trader_ServiceDesc is the grpc.ServiceDesc for Trader service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trader_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "poolrpc.Trader",
	HandlerType: (*TraderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _Trader_GetInfo_Handler,
		},
		{
			MethodName: "StopDaemon",
			Handler:    _Trader_StopDaemon_Handler,
		},
		{
			MethodName: "QuoteAccount",
			Handler:    _Trader_QuoteAccount_Handler,
		},
		{
			MethodName: "InitAccount",
			Handler:    _Trader_InitAccount_Handler,
		},
		{
			MethodName: "ListAccounts",
			Handler:    _Trader_ListAccounts_Handler,
		},
		{
			MethodName: "CloseAccount",
			Handler:    _Trader_CloseAccount_Handler,
		},
		{
			MethodName: "WithdrawAccount",
			Handler:    _Trader_WithdrawAccount_Handler,
		},
		{
			MethodName: "DepositAccount",
			Handler:    _Trader_DepositAccount_Handler,
		},
		{
			MethodName: "RenewAccount",
			Handler:    _Trader_RenewAccount_Handler,
		},
		{
			MethodName: "BumpAccountFee",
			Handler:    _Trader_BumpAccountFee_Handler,
		},
		{
			MethodName: "RecoverAccounts",
			Handler:    _Trader_RecoverAccounts_Handler,
		},
		{
			MethodName: "AccountModificationFees",
			Handler:    _Trader_AccountModificationFees_Handler,
		},
		{
			MethodName: "SubmitOrder",
			Handler:    _Trader_SubmitOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Trader_ListOrders_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Trader_CancelOrder_Handler,
		},
		{
			MethodName: "QuoteOrder",
			Handler:    _Trader_QuoteOrder_Handler,
		},
		{
			MethodName: "AuctionFee",
			Handler:    _Trader_AuctionFee_Handler,
		},
		{
			MethodName: "LeaseDurations",
			Handler:    _Trader_LeaseDurations_Handler,
		},
		{
			MethodName: "NextBatchInfo",
			Handler:    _Trader_NextBatchInfo_Handler,
		},
		{
			MethodName: "BatchSnapshot",
			Handler:    _Trader_BatchSnapshot_Handler,
		},
		{
			MethodName: "GetLsatTokens",
			Handler:    _Trader_GetLsatTokens_Handler,
		},
		{
			MethodName: "Leases",
			Handler:    _Trader_Leases_Handler,
		},
		{
			MethodName: "NodeRatings",
			Handler:    _Trader_NodeRatings_Handler,
		},
		{
			MethodName: "BatchSnapshots",
			Handler:    _Trader_BatchSnapshots_Handler,
		},
		{
			MethodName: "OfferSidecar",
			Handler:    _Trader_OfferSidecar_Handler,
		},
		{
			MethodName: "RegisterSidecar",
			Handler:    _Trader_RegisterSidecar_Handler,
		},
		{
			MethodName: "ExpectSidecarChannel",
			Handler:    _Trader_ExpectSidecarChannel_Handler,
		},
		{
			MethodName: "DecodeSidecarTicket",
			Handler:    _Trader_DecodeSidecarTicket_Handler,
		},
		{
			MethodName: "ListSidecars",
			Handler:    _Trader_ListSidecars_Handler,
		},
		{
			MethodName: "CancelSidecar",
			Handler:    _Trader_CancelSidecar_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trader.proto",
}
